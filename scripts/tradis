#!/usr/bin/env python3

import argparse
import os
import sys
import pkg_resources  # part of setuptools

from quatradis.tags import add_tags, tags_in_alignment, remove_tags
from quatradis.isp_create import plot
from quatradis.isp_combine import combine
from quatradis.isp_analyse import analyse_insert_sites
from quatradis.tradis import run_tradis
from quatradis.mapper import index_reference

version = pkg_resources.require("quatradis")[0].version


def add_tags_options(parser):
    parser.add_argument('mapped_reads', type=str,
                        help='A SAM/BAM/CRAM file to check for tradis tags')
    parser.add_argument('-o', '--output', type=str,
                        help="Output BAM name (default: <file>.tr.bam)")
    parser.add_argument('-v', '--verbose', dest='verbose', action='store_true',
                        help='Add verbose output to console logs')


def add_tags(args):
    present = add_tags(args.mapped_reads, args.output)
    print(present)


def check_tags_options(parser):
    parser.add_argument('mapped_reads', type=str,
                        help='A SAM/BAM/CRAM file to check for tradis tags')


def check_tags(args):
    present = tags_in_alignment(args.mapped_reads)
    print(present)


def filter_tags_options(parser):
    parser.add_argument('fastq_in', type=str,
                        help='The fastq formatted file for processing (can be gzipped).')
    parser.add_argument('fastq_out', type=str,
                        help='The fastq formatted output file (can be gzipped based on extension).')
    parser.add_argument('-t', '--tag', type=str, required=True,
                        help='the tag to remove from fastq input')
    parser.add_argument('-mm', '--mismatch', type=str, default=0,
                        help='number of mismatches allowed when matching tag (default = 0)')


def filter_tags(args):
    remove_tags(args.fastq_in, args.fastq_out, tag=args.tag, max_mismatches=args.mismatch, filter=True, trim=False)


def remove_tags_options(parser):
    parser.add_argument('fastq_in', type=str,
                        help='The fastq formatted file for processing (can be gzipped).')
    parser.add_argument('fastq_out', type=str,
                        help='The fastq formatted output file (can be gzipped based on extension).')
    parser.add_argument('-t', '--tag', type=str, required=True,
                        help='the tag to remove from fastq input')
    parser.add_argument('-mm', '--mismatch', type=str, default=0,
                        help='number of mismatches allowed when matching tag (default = 0)')


def remove_tags(args):
    remove_tags(args.fastq_in, args.fastq_out, tag=args.tag, max_mismatches=args.mismatch, filter=False, trim=True)


def create_plot_options(parser):
    parser.add_argument('mapped_reads', type=str,
                        help='A SAM/BAM/CRAM file to check for tradis tags')
    parser.add_argument('-m', '--mapping_score', type=str, default=30,
                        help='mapping quality must be greater than X (Default: 30)')
    parser.add_argument('--outfile', default="tradis.plot",
                        help='Output file base name for plot (Default: tradis.plot)')


def create_plot(args):
    plot(args.mapped_reads, plot_out_prefix=args.outfile, cutoff_score=args.mapping_score)


def combine_plot_options(parser):
    parser.add_argument('plot_file_list', type=str,
                        help='A tab delimited file with id in the first column followed by a list of plot files')
    parser.add_argument('--combined_dir', dest='combined_dir', default="combined",
                        help='The directory in which to store the combined output files (default: combined)')


def combine_plots(args):
    combine(args.plot_file_list, args.combined_dir)


def analyse_plot_options(parser):
    parser.add_argument('embl_in', type=str,
                        help='The embl formatted annotation file')
    parser.add_argument('plot_in', type=str, nargs='+',
                        help='The insertion site plot files (can be gzipped)')
    parser.add_argument('-o', '--output_suffix', type=str, default="tradis_gene_insert_sites.csv",
                        help='The suffix to add to output files (optional, default = tradis_gene_insert_sites.csv)')
    parser.add_argument('--trim5', action='store_true',
                        help="Trim insertion sites from 5' end of gene")
    parser.add_argument('--trim3', action='store_true',
                        help="Trim insertion sites from 3' end of gene")
    parser.add_argument('-j', '--joined_output', action='store_true',
                        help="output a single file with all info.")
    parser.add_argument('-p', '--profile', dest='profile', action='store_true',
                        help='Turn on profiling.  Prints out cumulative time in each function to stdout and to an output file (<output_prefix>.profile).  The profile file can be read by tools such as snakeviz.')


def analyse_plot(args):
    if args.profile:
        import cProfile, pstats, io
        pr = cProfile.Profile()
        pr.enable()

    analyse_insert_sites(args.embl_in, args.plot_in, args.joined_output, args.output_suffix,
                         trim5=args.trim5, trim3=args.trim3)

    if args.profile:
        pr.disable()
        ps = pstats.Stats(pr).sort_stats('cumulative')
        print("\n\n..........Profiling stats\n")
        ps.print_stats()
        ps.dump_stats("isp_analysis.profile")


def single_pipeline_options(parser):
    parser.add_argument('fastq', type=str,
                        help='The fastq formatted reads for processing (can be gzipped).')
    parser.add_argument('reference', type=str,
                        help='The fasta formatted reference for processing.')
    parser.add_argument('-o', '--output_dir', dest='output_dir', default="",
                        help='The directory in which to put all output files (default: current working directory)')
    parser.add_argument('-p', '--output_prefix', dest='output_prefix', default="quatradis_out",
                        help='The filename prefix to use for all output files (default: quatradis_out)')
    parser.add_argument('-n', '--threads', default=1,
                        help='number of threads to use when mapping and sorting (default: 1)')
    parser.add_argument('-a', '--aligner', default="bwa",
                        help='mapping tool to use (bwa, smalt, minimap2, minimap2_long) (default: bwa)')
    parser.add_argument('-m', '--mapping_score', type=str, default=30,
                        help='mapping quality must be greater than X (Default: 30)')
    parser.add_argument('-t', '--tag', type=str, default="",
                        help='the tag to remove from fastq input (default: "")')
    parser.add_argument('-mm', '--mismatch', type=int, default=0,
                        help='number of mismatches allowed when matching tag (default: 0)')
    parser.add_argument('--profile', dest='profile', action='store_true',
                        help='Turn on profiling.  Prints out cumulative time in each function to stdout and to an output file (<output_prefix>.profile).  The profile file can be read by tools such as snakeviz.')
    parser.add_argument('-v', '--verbose', dest='verbose', action='store_true',
                        help='Add verbose output to console logs')


def run_single_pipeline(args):
    if args.profile:
        import cProfile, pstats, io
        pr = cProfile.Profile()
        pr.enable()

    output_prefix = os.path.join(args.output_dir, args.output_prefix) 

    run_tradis(args.fastq, args.reference, output_prefix, tag=args.tag,
               mapper=args.aligner, threads=args.threads, max_mismatches=args.mismatch,
               cutoff=args.mapping_score, verbose=args.verbose)

    if args.profile:
        pr.disable()
        ps = pstats.Stats(pr).sort_stats('cumulative')
        print("\n\n..........Profiling stats\n")
        ps.print_stats()
        ps.dump_stats(args.output_prefix + ".profile")


def multiple_pipeline_options(parser):
    parser.add_argument('fastqs', type=str,
                        help='The fastq formatted reads for processing (can be gzipped).')
    parser.add_argument('reference', type=str,
                        help='The fasta formatted reference for processing.')
    parser.add_argument('-o', '--output_dir', default="results",
                        help='The filename output_prefix to use for all output files (default: results)')
    parser.add_argument('-n', '--threads', type=int, default=1,
                        help='number of threads to use when mapping and sorting (default: 1)')
    parser.add_argument('-a', '--aligner', default="bwa",
                        help='mapping tool to use (bwa, smalt, minimap2) (default: bwa)')
    parser.add_argument('-m', '--mapping_score', type=int, default=30,
                        help='mapping quality must be greater than X (Default: 30)')
    parser.add_argument('-t', '--tag', type=str, default="",
                        help='the tag to remove from fastq input (default: "")')
    parser.add_argument('-mm', '--mismatch', type=int, default=0,
                        help='number of mismatches allowed when matching tag (default: 0)')
    parser.add_argument('-nc', '--nextflow_config', type=str,
                        help='If provided add the nexflow parameters in this file to combine with our defaults.  Use this to distribute processes over a cluster for example.  See nextflow docs for more details.')


def run_multiple_pipeline(args):
    with open(args.fastqs, 'r') as fql:
        fastqs = [x.strip() for x in fql.readlines() if x]
        with open("quadtradis_nf.fastq.txt", 'w') as ofql:
            ofql.write("\n".join(fastqs))

    nfcfg = ""
    if args.nextflow_config:
        nfcfg = "-c " + args.nextflow_config

    os.system("nextflow " + nfcfg + os.path.dirname(__file__) + "/../pipelines/multi_tradis.nf --reference " + args.reference +
              " --fastqs quadtradis_nf.fastq.txt --refname myref --outdir " + args.output_dir +
              " --tag " + args.tag + " --aligner " + args.aligner + " --threads " + str(args.threads) +
              " --mismatch " + str(args.mismatch) + " --mapping_score " + str(args.mapping_score))


def index_utils_options(parser):
    parser.add_argument('reference', type=str,
                        help='The fasta formatted reference for processing.')
    parser.add_argument('refname', type=str,
                        help='The name for this reference.')
    parser.add_argument('-a', '--aligner', type=str, default="bwa",
                        help='read aligning tool to use (bwa, smalt, minimap2) (default: bwa)')
    parser.add_argument('-r', '--read_len', type=int,
                        help='the average read length used')
    parser.add_argument('-sk', '--smalt_k', type=int,
                        help='the average read length used')
    parser.add_argument('-ss', '--smalt_s', type=int,
                        help='the average read length used')


def index_reference(args):
    index_reference(args.reference, args.refname, args.read_len, mapper=args.aligner)


def create_parser(name, subparsers, function, options, help_message, description=""):
    if not description:
        description = help_message

    parser = subparsers.add_parser(name, help=help_message, description=description)
    options(parser)
    parser.set_defaults(func=function)


def main():
    call_args = sys.argv[1:]

    parser = argparse.ArgumentParser(
        """This script contains a number of tools for running or supporting tradis.""",
        formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument("-V", "--version", action='store_true', default=False, help="Output the software version")

    subparsers = parser.add_subparsers(title="Tradis Tools")

    tags_parser_desc = "Tradis tagging tools"
    tags_parser = subparsers.add_parser("tags", help=tags_parser_desc)
    tags_subparsers = tags_parser.add_subparsers(title=tags_parser_desc)
    create_parser("add", tags_subparsers, add_tags, add_tags_options, "Add given tags to the start of the sequence.")
    create_parser("check", tags_subparsers, check_tags, check_tags_options, "Check for the existence of tradis tags in a sam/bam/cram file.")
    create_parser("filter", tags_subparsers, filter_tags, filter_tags_options, "Filters transposon sequence and quality tags from the read strings.")
    create_parser("remove", tags_subparsers, remove_tags, remove_tags_options, "Removes transposon sequence and quality tags from the read strings.")

    plot_parser_desc = "Tradis plot file tools"
    plot_parser = subparsers.add_parser("plot", help=plot_parser_desc)
    plot_subparsers = plot_parser.add_subparsers(title=plot_parser_desc)
    create_parser("create", plot_subparsers, create_plot, create_plot_options, "Create insertion site plot file from mapped reads.")
    create_parser("combine", plot_subparsers, combine_plots, combine_plot_options, "Combine multiple tradis plot files into one.",
                  description='''Combine multiple tradis plot files into one.  
Also can combine plots files in groups.  The plot combining process is controlled via a tab-delimited file with an ID as 
the first column followed by a list of plotfiles to combine per row. The ID will be used to name the new plotfile and as 
an identifier in the stats file, so ensure these are unique.''')
    create_parser("analyse", plot_subparsers, analyse_plot, analyse_plot_options, "Produce summary of insert site details from one or more plot files",
                  description="Take in one or more plot files and an embl file to produce a tab delimited file with insert site details to use as input to another script to test for essentiality.")

    pipeline_parser_desc = "Tradis pipelines that stitch together other tools in this package."
    pipeline_parser = subparsers.add_parser("pipeline", help=pipeline_parser_desc)
    pipeline_subparsers = pipeline_parser.add_subparsers(title=pipeline_parser_desc)
    create_parser("single", pipeline_subparsers, run_single_pipeline, single_pipeline_options, "Runs full tradis pipeline for a single fastq to produce a insertion site plot file.")
    create_parser("multiple", pipeline_subparsers, run_multiple_pipeline, multiple_pipeline_options, "Runs full tradis pipeline over multiple fastqs in parallel where possible using nextflow.",
                  description='''Runs full tradis pipeline across multiple fastqs in parallel producing plots files for
each.  This pipeline uses nextflow, therefore it is possible to customise how this operates to distribute the workload
across a cluster using a nextflow config file.''')

    utils_parser_desc = "Miscellaneous utilities."
    utils_parser = subparsers.add_parser("utils", help=utils_parser_desc)
    utils_subparsers = utils_parser.add_subparsers(title=utils_parser_desc)
    create_parser("index", utils_subparsers, index_reference, index_utils_options, "Index a reference using specified alignment tool.")

    args = parser.parse_args(call_args)
    if hasattr(args, "func"):
        args.func(args)
    elif args.version:
        print(version)
    else:
        parser.print_help()


if __name__ == '__main__':
    main()
